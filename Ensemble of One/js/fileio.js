(function () {
    WinJS.Namespace.define("Ensemble.FileIO", {
        /// <summary>Provides platform-agnostic interfaces for accessing the host device's file system.</summary>

        supportedVideoTypes: [".3g2", ".3gp2", ".3gp", ".3gpp", ".m4v", ".mp4v", ".mp4", ".mov", ".m2ts", ".asf", ".wm", ".wmv", ".avi"],
        supportedAudioTypes: [".m4a", ".wma", ".aac", ".adt", ".adts", ".mp3", ".wav", ".ac3", ".ec3"],
        supportedImageTypes: [".jpg", ".jpeg", ".png", ".gif", ".bmp"],

        _createProjectData: {
            callback: null,
            resolution: {width: 0, height: 0},
            composition: new Windows.Media.Editing.MediaComposition(),
            name: "",
            aspect: ""
        },

        _saveProjectOverrideFile: new Windows.Storage.StorageFile(),

        createProject: function (name, aspect, callback) {
            /// <summary>Creates save files for a new project.</summary>
            /// <param name="name" type="String">The name of the project.</param>
            /// <param name="aspect" type="String">The aspect ratio of the project (16:9, 4:3, etc.).</param>
            Ensemble.FileIO._createProjectData.resolution = Ensemble.Settings.getDefaultResolution(aspect);
            Ensemble.FileIO._createProjectData.composition = new Windows.Media.Editing.MediaComposition();
            Ensemble.FileIO._createProjectData.callback = callback;
            Ensemble.FileIO._createProjectData.name = name;
            Ensemble.FileIO._createProjectData.aspect = aspect;

            let fillerImageFilename = Ensemble.FileIO._createProjectData.resolution.width + "x" + Ensemble.FileIO._createProjectData.resolution.height + ".png";
            Windows.Storage.StorageFile.getFileFromApplicationUriAsync(new Windows.Foundation.Uri("ms-appx:///img/compositionFillers/" + fillerImageFilename)).then(function (fillerImage) {
                Windows.Media.Editing.MediaClip.createFromImageFileAsync(fillerImage, 0).then(function (fillerMediaClip) {
                    Ensemble.FileIO._createProjectData.composition.clips.append(fillerMediaClip);
                    Ensemble.FileIO._createProjectData.composition.overlayLayers.append(new Windows.Media.Editing.MediaOverlayLayer());
                    Ensemble.FileIO._generateCompositionXMLString(Ensemble.FileIO._createProjectData.composition, Ensemble.FileIO._generateNewProjectFile);
                });
            });
        },

        _generateNewProjectFile: function (compositionXML) {
            /// <param name="compositionXML" type="XMLDocument">The XML document generated by the MediaComposition API.</param>
            let projectData = Ensemble.FileIO._createProjectData;

            let xmlDoc = document.implementation.createDocument(null, "EnsembleOfOneProject", null),
                rootNode = xmlDoc.firstChild;

            let tempCanvas = document.createElement("canvas");
            tempCanvas.width = projectData.resolution.width * 0.25;
            tempCanvas.height = projectData.resolution.height * 0.25;
            let tempContext = tempCanvas.getContext("2d");
            tempContext.fillStyle = "#000";
            tempContext.fillRect(0, 0, projectData.resolution.width * 0.25, projectData.resolution.height * 0.25);
            let thumbNode = xmlDoc.createElement("ProjectThumb");
            thumbNode.appendChild(xmlDoc.createTextNode(tempCanvas.toDataURL("image/png")));
            rootNode.appendChild(thumbNode);

            let countNode = xmlDoc.createElement("NumberOfClips");
            countNode.appendChild(xmlDoc.createTextNode("0"));
            rootNode.appendChild(countNode);

            let aspectNode = xmlDoc.createElement("AspectRatio");
            aspectNode.appendChild(xmlDoc.createTextNode(projectData.aspect));
            rootNode.appendChild(aspectNode);

            let resNode = xmlDoc.createElement("Resolution");
            resNode.setAttribute("width", projectData.resolution.width.toString());
            resNode.setAttribute("height", projectData.resolution.height.toString());
            rootNode.appendChild(resNode);

            let lengthNode = xmlDoc.createElement("ProjectLength");
            lengthNode.appendChild(xmlDoc.createTextNode("0"));
            rootNode.appendChild(lengthNode);

            let trackContainerNode = xmlDoc.createElement("Tracks"),
                trackData = JSON.stringify([Ensemble.Editor.TimelineMGR.generateNewTrackMap()]);
            trackContainerNode.setAttribute("FreeTrackId", "1");
            trackContainerNode.setAttribute("FreeClipId", "0");
            trackContainerNode.setAttribute("trackData", trackData);
            rootNode.appendChild(trackContainerNode);

            let historyNode = xmlDoc.createElement("History"),
                undoNode = xmlDoc.createElement("Undo"),
                redoNode = xmlDoc.createElement("Redo");
            historyNode.appendChild(undoNode);
            historyNode.appendChild(redoNode);
            rootNode.appendChild(historyNode);

            rootNode.appendChild(compositionXML.getElementsByTagName("Composition")[0]);

            let xmlSerializer = new XMLSerializer();

            Windows.Storage.ApplicationData.current.localFolder.createFolderAsync("Projects", Windows.Storage.CreationCollisionOption.openIfExists).then(function (projectDir) {
                projectDir.createFileAsync(projectData.name + ".eo1", Windows.Storage.CreationCollisionOption.generateUniqueName).then(function (projectFile) {
                    Windows.Storage.FileIO.writeTextAsync(projectFile, xmlSerializer.serializeToString(xmlDoc)).then(function () {
                        Ensemble.FileIO._createProjectData.callback(projectFile);
                        Ensemble.FileIO._createProjectData.callback = null;
                    });
                });
            });
        },

        loadProject: function (file, internal) {
            /// <summary>Loads a saved project from storage external to the application.</summary>
            /// <param name="file" type="Windows.Storage.StorageFile">The project file to load.</param>
            /// <param name="internal" type="Boolean">Optional. If true, treat the project as an unsaved internal project.</param>
            Ensemble.FileIO.addOrReplaceRecentProject(file);
            Ensemble.Session.projectFile = file;
            Ensemble.Session.projectFileInApp = internal;
            file.getBasicPropertiesAsync().then(function (basicProperties) {
                Ensemble.Session.projectFileBasicProperties = basicProperties;
                Windows.Storage.FileIO.readTextAsync(file).then(function (contents) {
                    Ensemble.FileIO._processLoadedProjectData(file.name, file.displayName, contents);
                });
            });
        },

        _processLoadedProjectData: function (filename, projectName, xmlString) {
            /// <param name="filename" type="String">The project's filename.</param>
            /// <param name="projectName" type="String">The name of the project.</param>
            /// <param name="xmlString" type="String">An XML string containing the project data.</param>
            let parser = new DOMParser(),
                xmlDoc = parser.parseFromString(xmlString, "text/xml"),
                ensembleProject = xmlDoc.getElementsByTagName("EnsembleOfOneProject")[0];

            let correctedProjectName = projectName.toLowerCase();
            if (correctedProjectName.slice(-4) == ".eo1") correctedProjectName = projectName.substr(0, projectName.length - 4);
            else correctedProjectName = projectName;

            console.log("Loading project \"" + correctedProjectName + "...\"");

            let projectThumb = xmlDoc.getElementsByTagName("ProjectThumb")[0].childNodes[0].nodeValue,
                dateModified = Ensemble.Session.projectFileBasicProperties.dateModified,
                dateCreated = Ensemble.Session.projectFile.dateCreated,
                numberOfClips = parseInt(xmlDoc.getElementsByTagName("NumberOfClips")[0].childNodes[0].nodeValue, 10),
                aspectRatio = xmlDoc.getElementsByTagName("AspectRatio")[0].childNodes[0].nodeValue,
                resolution = {
                    width: parseInt(xmlDoc.getElementsByTagName("Resolution")[0].getAttribute("width"), 10),
                    height: parseInt(xmlDoc.getElementsByTagName("Resolution")[0].getAttribute("height"), 10)
                },
                duration = parseInt(xmlDoc.getElementsByTagName("ProjectLength")[0].childNodes[0].nodeValue, 10),
                compositionXML = (new XMLSerializer()).serializeToString(xmlDoc.getElementsByTagName("Composition")[0]),
                freeTrackId = parseInt(xmlDoc.getElementsByTagName("Tracks")[0].getAttribute("FreeTrackId")),
                freeClipId = parseInt(xmlDoc.getElementsByTagName("Tracks")[0].getAttribute("FreeClipId")),
                trackData = JSON.parse(xmlDoc.getElementsByTagName("Tracks")[0].getAttribute("trackData")),

                historyParent = xmlDoc.getElementsByTagName("History")[0],
                undoParent = historyParent.getElementsByTagName("Undo")[0],
                redoParent = historyParent.getElementsByTagName("Redo")[0],
                undoItems = undoParent.getElementsByTagName("HistoryAction"),
                redoItems = redoParent.getElementsByTagName("HistoryAction"),
                undoCount = undoItems.length,
                redoCount = redoItems.length,
                undoStack = [],
                redoStack = [];

            for (let i = 0; i < undoCount; i++) {
                undoStack.push(JSON.parse(undoItems[i].getAttribute("historyData")));
            }

            for (let i = 0; i < redoCount; i++) {
                redoStack.push(JSON.parse(redoItems[i].getAttribute("historyData")));
            }

            Ensemble.Session.projectAspect = aspectRatio;
            Ensemble.Session.projectResolution = resolution;
            Ensemble.Session.projectFilename = filename;
            Ensemble.Session.projectName = correctedProjectName;
            Ensemble.Session.projectThumb = projectThumb;
            Ensemble.Session.projectDuration = duration;
            Ensemble.Session.projectDateModified = dateModified;
            Ensemble.Session.projectDateCreated = dateCreated;
            Ensemble.Session.projectClipCount = numberOfClips;

            //May be overridden during the rest of the load process due to missing or invalid clip references.
            Ensemble.Session.projectTrackCount = trackData.length;
            Ensemble.Editor.TimelineMGR.uniqueTrackID = freeTrackId;
            Ensemble.Editor.TimelineMGR.uniqueClipID = freeClipId;
            Ensemble.Editor.TimelineMGR.tracks = trackData;

            Ensemble.HistoryMGR._backStack = undoStack;
            Ensemble.HistoryMGR._forwardStack = redoStack;

            Ensemble.FileIO._loadCompositionFromXMLString(compositionXML);
        },

        _loadCompositionFromXMLString: function (compositionXML) {
            Windows.Storage.ApplicationData.current.temporaryFolder.createFileAsync("tmp.cmp", Windows.Storage.CreationCollisionOption.generateUniqueName).then(function (compositionFile) {
                Windows.Storage.FileIO.writeTextAsync(compositionFile, compositionXML).then(function () {
                    Windows.Media.Editing.MediaComposition.loadAsync(compositionFile).done(function (loadedComposition) {
                        Ensemble.Editor.TimelineMGR.mediaComposition = loadedComposition;
                        Ensemble.MainMenu._listeners.projectFinishedLoading();
                    }, function (error) {
                        console.error("Error loading composition: " + error);
                    });
                });
            });
        },

        saveProject: function (overrideFile) {
            /// <summary>Saves the currently project to disk.</summary>
            /// <param name="overrideFile" type="Windows.Storage.StorageFile">Optional. If specified, set this file as the active file for the current project and then save the project to disk.</param>
            Ensemble.FileIO._saveProjectOverrideFile = overrideFile;
            Ensemble.FileIO._generateCompositionXMLString(Ensemble.Editor.TimelineMGR.mediaComposition, Ensemble.FileIO._writeProjectSaveData);
        },

        _generateCompositionXMLString: function (composition, callback) {
            /// <summary>Saves the specified MediaComposition to an XML string and passes the result to the specified callback.</summary>
            /// <param name="composition" type="Windows.Media.Editing.MediaComposition">The MediaComposition to convert to XML.</param>
            /// <param name="callback" type="Function">The callback to execute after the asynchronous operation completes.</param>
            Windows.Storage.ApplicationData.current.temporaryFolder.createFileAsync("tmp.cmp", Windows.Storage.CreationCollisionOption.generateUniqueName).then(function (compositionFile) {
                composition.saveAsync(compositionFile).then(function () {
                    Windows.Storage.FileIO.readTextAsync(compositionFile).done(function (compositionXML) {
                        compositionFile.deleteAsync(Windows.Storage.StorageDeleteOption.permanentDelete);
                        let parser = new DOMParser(),
                            xmlDoc = parser.parseFromString(compositionXML, "text/xml");
                        callback(xmlDoc);
                    });
                });
            });
        },

        _writeProjectSaveData: function (compositionXML) {
            /// <param name="compositionXML" type="XMLDocument">The XML document generated by the MediaComposition API.</param>
            let xmlDoc = document.implementation.createDocument(null, "EnsembleOfOneProject", null),
                rootNode = xmlDoc.firstChild;

            let tempCanvas = document.createElement("canvas");
            tempCanvas.width = projectData.resolution.width * 0.25;
            tempCanvas.height = projectData.resolution.height * 0.25;
            let tempContext = tempCanvas.getContext("2d");
            tempContext.fillStyle = "#000";
            tempContext.fillRect(0, 0, projectData.resolution.width * 0.25, projectData.resolution.height * 0.25);
            let thumbNode = xmlDoc.createElement("ProjectThumb");
            thumbNode.appendChild(xmlDoc.createTextNode(tempCanvas.toDataURL("image/png")));
            rootNode.appendChild(thumbNode);

            let countNode = xmlDoc.createElement("NumberOfClips");
            countNode.appendChild(xmlDoc.createTextNode(Ensemble.Session.projectClipCount.toString(10)));
            rootNode.appendChild(countNode);

            let aspectNode = xmlDoc.createElement("AspectRatio");
            aspectNode.appendChild(xmlDoc.createTextNode(Ensemble.Session.projectAspect));
            rootNode.appendChild(aspectNode);

            let resNode = xmlDoc.createElement("Resolution");
            resNode.setAttribute("width", Ensemble.Session.projectResolution.width.toString(10));
            resNode.setAttribute("height", Ensemble.Session.projectResolution.height.toString(10));
            rootNode.appendChild(resNode);

            let lengthNode = xmlDoc.createElement("ProjectLength");
            lengthNode.appendChild(xmlDoc.createTextNode(Ensemble.Session.projectDuration.toString(10)));
            rootNode.appendChild(lengthNode);

            let trackContainerNode = xmlDoc.createElement("Tracks"),
                trackData = JSON.stringify(Ensemble.Editor.TimelineMGR.tracks);
            trackContainerNode.setAttribute("FreeTrackId", Ensemble.Editor.TimelineMGR.uniqueTrackID.toString(10));
            trackContainerNode.setAttribute("FreeClipId", Ensemble.Editor.TimelineMGR.uniqueClipID.toString(10));
            trackContainerNode.setAttribute("trackData", trackData);
            rootNode.appendChild(trackContainerNode);

            let historyNode = xmlDoc.createElement("History"),
                undoNode = xmlDoc.createElement("Undo"),
                redoNode = xmlDoc.createElement("Redo"),
                undoCount = Ensemble.HistoryMGR._backStack.length,
                redoCount = Ensemble.HistoryMGR._forwardStack.length;

            // Iterate through all history items and serialize
            for (let i = 0; i < undoCount; i++) {
                let singleHistoryItemNode = xmlDoc.createElement("HistoryAction");
                singleHistoryItemNode.setAttribute("historyData", JSON.stringify(Ensemble.HistoryMGR._backStack[i]._payload));
                undoNode.appendChild(singleHistoryItemNode);
            }

            for (let i = 0; i < redoCount; i++) {
                let singleHistoryItemNode = xmlDoc.createElement("HistoryAction");
                singleHistoryItemNode.setAttribute("historyData", JSON.stringify(Ensemble.HistoryMGR._forwardStack[i]._payload));
                redoNode.appendChild(singleHistoryItemNode);
            }

            historyNode.appendChild(undoNode);
            historyNode.appendChild(redoNode);
            rootNode.appendChild(historyNode);

            rootNode.appendChild(compositionXML.getElementsByTagName("Composition")[0]);

            let xmlSerializer = new XMLSerializer(),
                serializedXML = xmlSerializer.serializeToString(rootNode);

            if (Ensemble.FileIO._saveProjectOverrideFile != null) {
                // Set the new save location for the project and write the data.
                Windows.Storage.FileIO.writeTextAsync(Ensemble.FileIO._saveProjectOverrideFile, serializedXML).then(function (complete) {
                    if (Ensemble.Session.projectFileInApp) {
                        // Remove the old project file from internal storage
                        Ensemble.Session.projectFile.deleteAsync(Windows.Storage.StorageDeleteOption.permanentDelete).done(function () {
                            Ensemble.FileIO.removeRecentProject(Ensemble.Session.projectFile);
                            Ensemble.FileIO.addOrReplaceRecentProject(Ensemble.FileIO._saveProjectOverrideFile);
                            Ensemble.Session.projectFile = Ensemble.FileIO._saveProjectOverrideFile;
                            Ensemble.FileIO._saveProjectOverrideFile = null;
                            Ensemble.Session.projectFileInApp = false;
                        });
                    }
                    else {
                        Ensemble.Session.projectFile = Ensemble.FileIO._saveProjectOverrideFile;
                        Ensemble.FileIO._saveProjectOverrideFile = null;
                    }
                });
            }

            else {
                Windows.Storage.FileIO.writeTextAsync(Ensemble.Session.projectFile, serializedXML).done(function (complete) {
                    console.info("Saved " + Ensemble.Session.projectName + ".");
                });
            }
        },


        /* Old unsorted code */
        requestSaveAs: function () {
            /// <summary>Show a "Save as..." dialog to the user.</summary>
            let savePicker = new Windows.Storage.Pickers.FileSavePicker();
            savePicker.suggestedFileName = Ensemble.Session.projectName;
            savePicker.suggestedStartLocation = Windows.Storage.Pickers.PickerLocationId.desktop;
            savePicker.fileTypeChoices.insert("Ensemble of One Project", [".eo1"]);
            savePicker.pickSaveFileAsync().then(Ensemble.FileIO._confirmSaveAs)
        },

        _confirmSaveAs: function (file) {
            /// <summary>Return function for the save as picker.</summary>
            /// <param name="file" type="Windows.Storage.StorageFile">The file picked by the user.</param>
            if (file) {
                Ensemble.FileIO.saveProject(file);
                let appView = Windows.UI.ViewManagement.ApplicationView.getForCurrentView();
                appView.title = file.displayName;
            }
        },
        

        enumerateLocalProjects: function (callback) {
            /// <summary>Enumerates all available projects in the project directory.</summary>
            /// <param name="callback" type="Function">The callback to be fired after all projects have been enumerated.</param>
            var dataArray = [];
            Windows.Storage.ApplicationData.current.localFolder.getFolderAsync("Projects").then(function (projectDir) {
                var projectQueryOptions = new Windows.Storage.Search.QueryOptions(Windows.Storage.Search.CommonFileQuery.orderByName, [".eo1"]);
                var projectQuery = projectDir.createFileQueryWithOptions(projectQueryOptions);
                projectQuery.getFilesAsync().then(function (projectFiles) {
                    if (projectFiles.length == 0) callback([]);
                    else {
                        for (var i = 0; i < projectFiles.length; i++) {
                            (function () {
                                let currentFile = projectFiles[i],
                                    loadedFilename = projectFiles[i].name,
                                    loadedProjectName = projectFiles[i].displayName;
                                projectFiles[i].getBasicPropertiesAsync().then(function (basicProperties) {
                                    Windows.Storage.FileIO.readTextAsync(currentFile).then(function (contents) {
                                        var parser = new DOMParser();
                                        var xmlDoc = parser.parseFromString(contents, "text/xml");

                                        let ensembleProject = xmlDoc.firstChild,
                                            loadedDateModified = basicProperties.dateModified,
                                            loadedAspectRatio = xmlDoc.getElementsByTagName("AspectRatio")[0].childNodes[0].nodeValue,
                                            loadedNumberOfClips = xmlDoc.getElementsByTagName("MediaClip").length,
                                            loadedProjectLength = xmlDoc.getElementsByTagName("ProjectLength")[0].childNodes[0].nodeValue,
                                            loadedThumbnailPath = xmlDoc.getElementsByTagName("ProjectThumb")[0].childNodes[0].nodeValue;

                                        dataArray.push(new Ensemble.Editor.ProjectFile(loadedProjectName, loadedFilename, loadedDateModified, loadedNumberOfClips, loadedAspectRatio, loadedProjectLength, loadedThumbnailPath, null, currentFile));
                                        dataArray[dataArray.length - 1].internal = true;

                                        if (dataArray.length == projectFiles.length) {
                                            dataArray.sort(function (a, b) {
                                                if (a.name.toLowerCase() < b.name.toLowerCase()) return -1;
                                                if (a.name.toLowerCase() > b.name.toLowerCase()) return 1;
                                                return 0;
                                            });
                                            callback(dataArray);
                                        }
                                    });
                                });
                            })();
                        }
                    }
                });
            });
        },

        enumerateRecentProjects: function (callback) {
            /// <summary>Generates all recently edited projects.</summary>
            /// <param name="callback" type="Function">The callback to be fired after all projects have been enumerated.</param>
            let dataArray = [],
                errorArray = [],
                projectTokens = Ensemble.Settings.getRecentProjectTokens(),
                projectCount = projectTokens.length,
                mostRecentlyUsedList = Windows.Storage.AccessCache.StorageApplicationPermissions.mostRecentlyUsedList;

            for (let i = 0; i < projectCount; i++) {
                (function () {
                    let iter = i;
                    mostRecentlyUsedList.getFileAsync(projectTokens[iter]).then(function (projectFile) {
                        let loadedFilename = projectFile.name,
                            loadedProjectName = projectFile.displayName;
                        projectFile.getBasicPropertiesAsync().then(function (basicProperties) {
                            Windows.Storage.FileIO.readTextAsync(projectFile).done(function (contents) {
                                let parser = new DOMParser(),
                                    xmlDoc = parser.parseFromString(contents, "text/xml"),
                                    ensembleProject = xmlDoc.firstChild,
                                    loadedAspectRatio = xmlDoc.getElementsByTagName("AspectRatio")[0].childNodes[0].nodeValue,
                                    loadedNumberOfClips = xmlDoc.getElementsByTagName("MediaClip").length,
                                    loadedProjectLength = xmlDoc.getElementsByTagName("ProjectLength")[0].childNodes[0].nodeValue,
                                    loadedThumbnailPath = xmlDoc.getElementsByTagName("ProjectThumb")[0].childNodes[0].nodeValue,
                                    loadedDateModified = basicProperties.dateModified;

                                dataArray.push(new Ensemble.Editor.ProjectFile(loadedProjectName, loadedFilename, loadedDateModified, loadedNumberOfClips, loadedAspectRatio, loadedProjectLength, loadedThumbnailPath, iter, projectFile));

                                Ensemble.FileIO._enumerateRecentProjectsCompletionTest(dataArray, errorArray, projectCount, callback);
                            });
                        });
                    }, function (error) {
                        console.error("Unable to lookup recent project.");
                        projectCount--;
                        errorArray.push(projectTokens[iter]);
                        Ensemble.FileIO._enumerateRecentProjectsCompletionTest(dataArray, errorArray, projectCount, callback);
                    });
                })();
            }
        },

        _enumerateRecentProjectsCompletionTest: function (dataArray, errorArray, count, callback) {
            if (dataArray.length == count) {
                dataArray.sort(function (a, b) {
                    if (a.extra < b.extra) return -1;
                    if (a.extra > b.extra) return 1;
                    return 0;
                });
                for (let i = 0; i < errorArray.length; i++) {
                    Windows.Storage.AccessCache.StorageApplicationPermissions.mostRecentlyUsedList.remove(errorArray[i]);
                    Ensemble.Settings.removeRecentProject(errorArray[i]);
                }
                callback(dataArray);
            }
        },

        pruneDuplicateProjects: function (projects) {
            /// <summary>Returns a new array with no duplicate projects. Biased toward keeping "internal" (unsaved) project.</summary>
            /// <param name="projects" type="Array"></param>
            /// <returns type="Array"></returns>
            let prunedList = [],
                projectCount = projects.length;
            
            for (let i = 0; i < projectCount; i++) {
                let found = false;
                for (let k = 0; k < prunedList.length; k++) {
                    if (prunedList[k].src.isEqual(projects[i].src)) {
                        found = true;
                        if (projects[i].internal) prunedList[k] = projects[i];
                    }
                }
                if (!found) prunedList.push(projects[i]);
            }

            return prunedList;
        },

        _generateAccessToken: function (file, callback, payload) {
            Windows.Storage.StorageFile.getFileFromPathAsync(file.path).done(function (complete) {
                //No token necessary - the file is accessible via path (is in a known library).
                callback(file, payload);
            }, function (error) {
                if (Windows.Storage.AccessCache.StorageApplicationPermissions.futureAccessList.entries.length == Windows.Storage.AccessCache.StorageApplicationPermissions.futureAccessList.maximumItemsAllowed) {
                    Ensemble.FileIO._removeOldestAccessToken();
                }
                file.token = Windows.Storage.AccessCache.StorageApplicationPermissions.futureAccessList.add(file._src, new Date().getTime());
                callback(file, payload);
            })
        },

        _removeOldestAccessToken: function () {
            /// <summary>Removes the oldest file access token from the Windows FutureAccessList.</summary>
            let min = Infinity;
            let token = null;
            for (let i = 0; i < Windows.Storage.AccessCache.StorageApplicationPermissions.futureAccessList.entries.length; i++) {
                if (min > parseInt(Windows.Storage.AccessCache.StorageApplicationPermissions.futureAccessList.entries[i].metadata, 10)) {
                    min = parseInt(Windows.Storage.AccessCache.StorageApplicationPermissions.futureAccessList.entries[i].metadata, 10)
                    token = Windows.Storage.AccessCache.StorageApplicationPermissions.futureAccessList.entries[i].token;
                }
            }
            Windows.Storage.AccessCache.StorageApplicationPermissions.futureAccessList.remove(token);
        },

        deleteProject: function (filename) {
            /// <summary>Permanently deletes the project with the given filename.</summary>
            /// <param name="filename" type="String">The filename of the project to be deleted.</param>
            var dataArray = [];
            Windows.Storage.ApplicationData.current.localFolder.getFolderAsync("Projects").then(function (projectDir) {
                projectDir.getFileAsync(filename).then(function (projectFile) {
                    projectFile.deleteAsync(Windows.Storage.StorageDeleteOption.permanentDelete).then(function (done) {
                        console.log("Deleted project file.");
                    });
                });
                projectDir.getFileAsync(filename + ".jpg").then(function (projectFile) {
                    projectFile.deleteAsync(Windows.Storage.StorageDeleteOption.permanentDelete).then(function (done) {
                        console.log("Deleted project thumbnail.");
                    });
                });
            });
        },

        deleteAllProjects: function () {
            /// <summary>Permanently deletes all projects and their accompanying thumbnails.</summary>
            console.log("Deleting all projects...");

            Windows.Storage.ApplicationData.current.localFolder.getFolderAsync("Projects").then(function (projectDir) {
                var projectQueryOptions = new Windows.Storage.Search.QueryOptions(Windows.Storage.Search.CommonFileQuery.orderByName, [".eo1", ".jpg"]);
                var projectQuery = projectDir.createFileQueryWithOptions(projectQueryOptions);
                projectQuery.getFilesAsync().then(function (projectFiles) {
                    if (projectFiles.length > 0) {
                        for (var i = 0; i < projectFiles.length; i++) {
                            projectFiles[i].deleteAsync(Windows.Storage.StorageDeleteOption.permanentDelete);
                        }
                        console.info("Deleted all projects.");
                    }
                    else console.log("No projects to delete.");
                });
            });
        },

        showMediaFilePicker: function (callback, payload) {
            let openPicker = new Windows.Storage.Pickers.FileOpenPicker();
            openPicker.viewMode = Windows.Storage.Pickers.PickerViewMode.list;
            openPicker.suggestedStartLocation = Windows.Storage.Pickers.PickerLocationId.videosLibrary;
            openPicker.fileTypeFilter.replaceAll(Ensemble.FileIO.supportedAudioTypes.concat(Ensemble.FileIO.supportedImageTypes).concat(Ensemble.FileIO.supportedVideoTypes));
            openPicker.pickSingleFileAsync().then(function (file) {
                if (file) {
                    let newFile = Ensemble.FileIO._createFileFromSrc(file);
                    Ensemble.FileIO.retrieveMediaProperties(newFile, newFile, function (index, returnVal, uniqueId) {
                        console.log("Picked a file.");
                        for (prop in returnVal) {
                            index[prop] = returnVal[prop];
                        }

                        Ensemble.FileIO._generateAccessToken(index, function (fileWithToken, filePayload) {
                            callback(fileWithToken, filePayload);
                        }, payload);
                    });
                } else {
                    console.log("Did not pick a file.");
                }
            });
        },

        addOrReplaceRecentProject: function (projectFile) {
            /// <summary>Adds the specified project file to the recent projects list.</summary>
            /// <param name="projectFile" type="Windows.Storage.StorageFile">The project file to add.</param>
            Ensemble.Settings.addOrReplaceRecentProjectToken(Windows.Storage.AccessCache.StorageApplicationPermissions.mostRecentlyUsedList.add(projectFile));
        },

        removeRecentProject: function (projectFile) {
            /// <summary>Removes the specified project file from the recent projects list.</summary>
            /// <param name="projectFile" type="Windows.Storage.StorageFile">The project file to remove.</param>
            let fileToken = Windows.Storage.AccessCache.StorageApplicationPermissions.mostRecentlyUsedList.add(projectFile);
            Windows.Storage.AccessCache.StorageApplicationPermissions.mostRecentlyUsedList.remove(fileToken);
            Ensemble.Settings.removeRecentProject(fileToken);
        }
    });
})();